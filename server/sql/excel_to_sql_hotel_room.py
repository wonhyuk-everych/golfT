#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import sys
import re
from pathlib import Path
from typing import Optional, Any, List

import pandas as pd

# Expected Excel column headers (Korean)
COLS = {
    "hotel_idx": "호텔코드",
    "room_name": "객실 명 ",
    "room_name_en": "객실 영문명",
    "view_type": "뷰 타입",
    "bed_type": "침대 타입",
    "breakfast_yn": "조식 여부",
}

# Fixed defaults
ADULT_DEFAULT = 3
CHILDREN_DEFAULT = 3
REFUND_YN_DEFAULT = "Y"
USE_YN_DEFAULT = "Y"
CREATED_MEMBER_IDX_DEFAULT = 1


def sql_escape(s: str) -> str:
    if s is None:
        return ""
    # Normalize newlines and escape backslashes and single quotes for MySQL
    s = s.replace("\r\n", "\n").replace("\r", "\n")
    s = s.replace("\\", "\\\\").replace("'", "\\'")
    return s


def clean_text(val: Any) -> Optional[str]:
    if val is None:
        return None
    if pd.isna(val):
        return None
    s = str(val).strip()
    if not s:
        return None
    return s


def val_str(s: Optional[str]) -> str:
    return "NULL" if s is None else f"'{sql_escape(s)}'"


def val_int(i: Optional[int]) -> str:
    return "NULL" if i is None else str(i)


def to_int_strict(val: Any) -> Optional[int]:
    if val is None or pd.isna(val):
        return None
    s = str(val).strip()
    if not s:
        return None
    m = re.fullmatch(r"-?\d+", s)
    if not m:
        return None
    try:
        return int(s)
    except Exception:
        return None


def get_col(df_row: pd.Series, header: str) -> Optional[str]:
    if header not in df_row:
        return None
    return clean_text(df_row[header])


def normalize_breakfast(val: Optional[str]) -> str:
    # Input is guaranteed Y/N or blank; blank => N
    if val is None:
        return "N"
    s = val.strip().upper()
    if s == "Y":
        return "Y"
    if s == "N":
        return "N"
    # Unexpected -> treat blank as N (safe default)
    return "N"


def generate_sql_line(row: pd.Series, row_idx: int) -> str:
    # Extract fields
    hotel_idx_raw = get_col(row, COLS["hotel_idx"])
    room_name = get_col(row, COLS["room_name"])
    room_name_en = get_col(row, COLS["room_name_en"])
    view_type = get_col(row, COLS["view_type"])
    bed_type = get_col(row, COLS["bed_type"])
    breakfast_yn = normalize_breakfast(get_col(row, COLS["breakfast_yn"]))

    # Required validations
    hotel_idx = to_int_strict(hotel_idx_raw)
    if hotel_idx is None:
        return f"-- SKIP row {row_idx}: Invalid or missing 호텔코드 '{hotel_idx_raw}'"

    if room_name is None:
        return f"-- SKIP row {row_idx}: Missing required '객실 명'"

    columns = [
        "`hotel_idx`",
        "`room_name`",
        "`room_name_en`",
        "`view_type`",
        "`bed_type`",
        "`breakfast_yn`",
        "`adult`",
        "`children`",
        "`refund_yn`",
        "`use_yn`",
        "`created_member_idx`",
    ]
    values = [
        str(hotel_idx),
        val_str(room_name),
        val_str(room_name_en),
        val_str(view_type),
        val_str(bed_type),
        val_str(breakfast_yn),
        str(ADULT_DEFAULT),
        str(CHILDREN_DEFAULT),
        val_str(REFUND_YN_DEFAULT),
        val_str(USE_YN_DEFAULT),
        str(CREATED_MEMBER_IDX_DEFAULT),
    ]

    return "INSERT INTO `hotel_room` ({cols}) VALUES ({vals});".format(
        cols=", ".join(columns),
        vals=", ".join(values),
    )


def run(excel_path: Path, sheet_name: str, out_path: Path) -> None:
    if not excel_path.exists():
        print(f"[ERROR] Excel file not found: {excel_path}", file=sys.stderr)
        sys.exit(1)

    try:
        df = pd.read_excel(excel_path, sheet_name=sheet_name, dtype=str, engine="openpyxl")
    except Exception as e:
        print(f"[ERROR] Failed to read Excel: {e}", file=sys.stderr)
        sys.exit(1)

    out_path.parent.mkdir(parents=True, exist_ok=True)

    lines: List[str] = []
    lines.append("-- Generated by excel_to_sql_hotel_room.py")
    lines.append(f"-- Source: {excel_path.name}, Sheet: {sheet_name}")
    lines.append("SET NAMES utf8mb4;")
    lines.append("START TRANSACTION;")
    lines.append("")

    total = len(df.index)
    inserted = 0
    skipped = 0

    for idx, row in df.iterrows():
        sql_or_comment = generate_sql_line(row, idx + 1)
        if sql_or_comment.startswith("INSERT INTO `hotel_room`"):
            inserted += 1
        else:
            skipped += 1
        lines.append(sql_or_comment)

    lines.append("COMMIT;")
    lines.append(f"-- Summary: total={total}, inserted={inserted}, skipped={skipped}")

    out_path.write_text("\n".join(lines), encoding="utf-8")
    print(f"[OK] SQL written to: {out_path}")
    print(f"[INFO] Summary: total={total}, inserted={inserted}, skipped={skipped}")


def main():
    parser = argparse.ArgumentParser(
        description="Generate SQL inserts for hotel_room data from an Excel sheet."
    )
    parser.add_argument("--excel", "-e", required=True, help="Path to the source Excel file")
    parser.add_argument(
        "--sheet", "-s", default="호텔_입력_호텔", help="Excel sheet name (default: 호텔_입력_호텔)"
    )
    parser.add_argument(
        "--out",
        "-o",
        default=None,
        help="Output .sql file path (default: server/sql/hotel_room_insert.sql relative to this script)",
    )
    args = parser.parse_args()

    excel_path = Path(args.excel).expanduser().resolve()
    script_dir = Path(__file__).resolve().parent
    default_out = (script_dir / "hotel_room_insert.sql").resolve()
    out_path = Path(args.out).expanduser().resolve() if args.out else default_out

    run(excel_path, args.sheet, out_path)


if __name__ == "__main__":
    main()